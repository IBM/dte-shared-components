function attacher(options) {
  var _options, _options$nodeType, _options$marker, _options$classNames, _options$tagType;

  options = (_options = options) != null ? _options : {}; // Prevents options from being null

  var Parser = this.Parser.prototype;
  var nodeType = (_options$nodeType = options.nodeType) != null ? _options$nodeType : 'underline';
  var marker = (_options$marker = options.marker) != null ? _options$marker : '__';
  var classNames = (_options$classNames = options.classNames) != null ? _options$classNames : ["underline"];
  var tagType = (_options$tagType = options.tagType) != null ? _options$tagType : 'ins';

  Parser.inlineTokenizers.underline = function underlineTokenizer(eat, value, silent) {
    if (value.startsWith(marker)) {
      var end = value.indexOf(marker, marker.length);

      if (end > -1) {
        if (silent) {
          return true;
        }

        var text = value.substring(marker.length, end);
        var now = eat.now();
        now.column += marker.length;
        now.offset += marker.length;
        return eat(marker + text + marker)({
          type: nodeType,
          children: this.tokenizeInline(text, now),
          data: {
            hName: tagType,
            hProperties: classNames.length ? {
              className: classNames
            } : {}
          }
        });
      }
    }

    return false;
  };

  Parser.inlineTokenizers.underline.locator = function (value, fromIndex) {
    return value.indexOf(marker, fromIndex);
  };

  Parser.inlineMethods.splice(Parser.inlineMethods.indexOf('strong'), 0, 'underline');
}

export default attacher;
//# sourceMappingURL=remark-underline.mjs.map
