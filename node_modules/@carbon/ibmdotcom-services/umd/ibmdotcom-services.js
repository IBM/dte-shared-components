(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.IBMDotcomServices = {}));
}(this, function (exports) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof2(obj) {
      if (typeof Symbol === "function" && _typeof_1(Symbol.iterator) === "symbol") {
        _typeof2 = function _typeof2(obj) {
          return _typeof_1(obj);
        };
      } else {
        _typeof2 = function _typeof2(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof_1(obj);
        };
      }

      return _typeof2(obj);
    }

    function _typeof(obj) {
      if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
        module.exports = _typeof = function _typeof(obj) {
          return _typeof2(obj);
        };
      } else {
        module.exports = _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };
      }

      return _typeof(obj);
    }

    module.exports = _typeof;
  });

  var lib = (typeof self === "undefined" ? "undefined" : _typeof_1(self)) === 'object' && self.self === self && self || _typeof_1(commonjsGlobal) === 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal || commonjsGlobal;

  /**
   * @constant {boolean} scrollTracker determines whether scroll tracking analytics is enabled
   * @private
   */

  var _scrollTracker = process && process.env.SCROLL_TRACKING === 'true' || false;
  /**
   * Current NODE_ENV
   *
   * @type {string | string}
   * @private
   */


  var _env = process && "development" || 'development';
  /**
   * Analytics API class with methods for firing analytics events on
   * ibm.com
   */


  var AnalyticsAPI = /*#__PURE__*/function () {
    function AnalyticsAPI() {
      classCallCheck(this, AnalyticsAPI);
    }

    createClass(AnalyticsAPI, null, [{
      key: "registerEvent",

      /**
       * This method checks that the analytics script has been loaded
       * and fires an event to Coremetrics
       *
       * @param {object} eventData Object with standard IBM metric event properties and values to send to Coremetrics
       *
       * @example
       * import { AnalyticsAPI } from '@carbon/ibmdotcom-services';
       *
       * function fireEvent() {
       *    const eventData = {
       *        type: 'element',
       *        primaryCategory: 'MASTHEAD',
       *        eventName: 'CLICK',
       *        executionPath: 'masthead__profile',
       *        execPathReturnCode: 'none',
       *        targetTitle: 'profile'
       *    }
       *    AnalyticsAPI.registerEvent(eventData);
       * }
       *
       *
       */
      value: function registerEvent(eventData) {
        if (lib.ibmStats) {
          lib.ibmStats.event(eventData);
        }
      }
      /**
       * Initializes all analytics global tracking init functions
       */

    }, {
      key: "initAll",
      value: function initAll() {
        this.initScrollTracker();
        this.initDynamicTabs();
        this.initModals();
      }
      /**
       *
       * If scroll tracking is enabled, this method will fire an event for every 400px
       * user scrolls down the page. Only the deepest depth will fire the event (e.g if
       * user scrolls back up the page, the event will not be triggered)
       *
       * @example
       * import { AnalyticsAPI } from '@carbon/ibmdotcom-services';
       *
       * function init() {
       *   AnalyticsAPI.initScrollTracker();
       * }
       **/

    }, {
      key: "initScrollTracker",
      value: function initScrollTracker() {
        if (_scrollTracker) {
          var trackingInterval = 400;
          var trackedMarker = 0;
          var curMarker = 0;
          var didScroll = false;
          var fireEvent = this.registerEvent;
          lib.addEventListener('scroll', function () {
            didScroll = true;
          });
          setInterval(function () {
            if (didScroll) {
              didScroll = false;
              curMarker = Math.floor(lib.pageYOffset / trackingInterval);

              if (curMarker > trackedMarker) {
                trackedMarker = curMarker;
                fireEvent({
                  type: 'element',
                  primaryCategory: 'SCROLL DISTANCE',
                  eventName: trackingInterval * trackedMarker,
                  executionPath: lib.innerWidth,
                  execPathReturnCode: lib.innerHeight
                });
              }
            }
          }, 50);
        }
      }
      /**
       * This instantiates an event listener to trigger an event if the Carbon
       * Tabs component is being interacted with by the user
       *
       * @example
       * import { AnalyticsAPI } from '@carbon/ibmdotcom-services';
       *
       * function init() {
       *   AnalyticsAPI.initDynamicTabs();
       * }
       */

    }, {
      key: "initDynamicTabs",
      value: function initDynamicTabs() {
        var tabSelected = this.triggerTabSelected.bind(this);
        lib.document.addEventListener('tab-selected', function (evt) {
          tabSelected(evt.target.id, evt.detail.item.innerText);
        });
      }
      /**
       * Triggers to CLICK event for the dynamic tabs
       *
       * @param {string} executionPath Target ID
       * @param {string} targetTitle Target innerText
       */

    }, {
      key: "triggerTabSelected",
      value: function triggerTabSelected(executionPath, targetTitle) {
        try {
          this.registerEvent({
            type: 'element',
            primaryCategory: 'WIDGET',
            eventName: 'CLICK',
            eventCategoryGroup: 'TABS DYNAMIC',
            executionPath: executionPath,
            targetTitle: targetTitle
          });
        } catch (err) {
          if (_env !== 'production') {
            console.error('Error triggering tab event:', err);
          }
        }
      }
      /**
       * This instantiates an event listener to trigger an event if the Carbon
       * Modal component is being interacted with by the user
       *
       * @example
       * import { AnalyticsAPI } from '@carbon/ibmdotcom-services';
       *
       * function init() {
       *   AnalyticsAPI.initModals();
       * }
       */

    }, {
      key: "initModals",
      value: function initModals() {
        var modalHide = this.triggerModalHide.bind(this);
        lib.document.addEventListener('modal-hidden', function (evt) {
          modalHide(evt.target.id, evt.detail.launchingElement.innerText);
        });
        var modalShow = this.triggerModalShow.bind(this);
        lib.document.addEventListener('modal-shown', function (evt) {
          modalShow(evt.target.id, evt.detail.launchingElement.innerText);
        });
      }
      /**
       * Triggers the HIDE event for the modal
       *
       * @param {string} executionPath Target ID
       * @param {string} targetTitle Target innerText
       */

    }, {
      key: "triggerModalHide",
      value: function triggerModalHide(executionPath, targetTitle) {
        try {
          this.registerEvent({
            type: 'element',
            primaryCategory: 'WIDGET',
            eventName: 'HIDE',
            eventCategoryGroup: 'SHOWHIDE',
            executionPath: executionPath,
            targetTitle: targetTitle
          });
        } catch (err) {
          if (_env !== 'production') {
            console.error('Error triggering modal hide event:', err);
          }
        }
      }
      /**
       * Triggers the SHOW event for the modal
       *
       * @param {string} executionPath Target ID
       * @param {string} targetTitle Target innerText
       */

    }, {
      key: "triggerModalShow",
      value: function triggerModalShow(executionPath, targetTitle) {
        try {
          this.registerEvent({
            type: 'element',
            primaryCategory: 'WIDGET',
            eventName: 'SHOW',
            eventCategoryGroup: 'SHOWHIDE',
            executionPath: executionPath,
            targetTitle: targetTitle
          });
        } catch (err) {
          if (_env !== 'production') {
            console.error('Error triggering modal show event:', err);
          }
        }
      }
      /**
       * Sends video player metrics data
       *
       * @param {object} data event data from the video player
       *
       * @example
       * import { AnalyticsAPI } from '@carbon/ibmdotcom-services';
       *
       *function init() {
       *    const data = {
       *       playerType: 'kaltura',
       *       title: 'Folgers Coffee',
       *       currentTime: 1,
       *       duration: 60,
       *       playerState: 1,
       *       videoId: '0_uka1msg4',
       *    };
       *
       *    AnalyticsAPI.videoPlayerStats(data);
       *}
       *
       */

    }, {
      key: "videoPlayerStats",
      value: function videoPlayerStats(data) {
        var playerState = '',
            currentTime = Math.floor(data.currentTime),
            duration = Math.floor(data.duration),
            percentWatched = Math.floor(currentTime / duration * 100); // Set nicenames for player states for event.

        switch (data.playerState) {
          case 0:
            playerState = 'launched';
            break;

          case 1:
            playerState = 'paused';
            break;

          case 2:
            playerState = 'played';
            break;

          case 3:
            playerState = 'ended';
            break;

          case 99:
            playerState = 'error';
            break;

          default:
        }

        if (currentTime === 0) {
          currentTime = 'start';
          percentWatched = '0';
        }

        if (currentTime >= duration || data.playerState === 3) {
          currentTime = 'end';
          percentWatched = '100';
        } // If went to the end of the video, and fired "pause" event, don't fire pause event b/c it's really
        // the end of the video, so just let "end" event fire and tag metrics.


        if (currentTime === 'end' && data.playerState === 1) {
          return;
        }

        var eventData = {
          type: 'video',
          primaryCategory: 'VIDEO',
          eventName: data.title,
          eventCategoryGroup: data.playerType,
          executionPath: data.videoId,
          execPathReturnCode: playerState,
          eventVidStatus: data.playerState,
          eventVidTimeStamp: currentTime,
          eventVidLength: duration,
          eventVidPlayed: percentWatched + '%'
        };

        try {
          this.registerEvent(eventData);
        } catch (err) {
          if (_env !== 'production') {
            console.error('Error firing video metrics:', err);
          }
        }
      }
    }]);

    return AnalyticsAPI;
  }();

  var runtime_1 = createCommonjsModule(function (module) {
    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};

      IteratorPrototype[iteratorSymbol] = function () {
        return this;
      };

      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          prototype[method] = function (arg) {
            return this._invoke(method, arg);
          };
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;

          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && _typeof_1(value) === "object" && hasOwn.call(value, "__await")) {
              return Promise.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return Promise.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new Promise(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      AsyncIterator.prototype[asyncIteratorSymbol] = function () {
        return this;
      };

      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  });

  var regenerator = runtime_1;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var asyncToGenerator = _asyncToGenerator;

  /**
   * Copyright IBM Corp. 2020
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Global settings
   *
   * @exports ibmdotcom.settings
   * @type {object} Settings object
   * @property {string} [prefix=dds]
   * IBM.com Library prefix
   *
   */
  var settings = {
    version: 'dds.v1.10.1',
    stablePrefix: 'dds'
  };

  /**
   * Returns boolean if the isDataLayerReady flag is true
   *
   * @returns {*} boolean flag if data layer is ready in the digitalData object
   * @private
   */

  function _checkFlag() {
    return lib.digitalData && lib.digitalData.page && lib.digitalData.page.isDataLayerReady;
  }
  /**
   * Number of times to retry the datalayer ready loop before failing
   *
   * @type {number}
   * @private
   */


  var _timeoutRetries = 50;

  var _dataLayerReadyPromise;
  /**
   * Timeout loop to check if the digitalData object is ready.
   * This is the only way to achieve this without jQuery, as the event trigger
   * is fired from jQuery's custom event layer as
   * $(document).trigger('datalayer_ready').
   *
   * Application should `window.digitalData` up-front, e.g. in a `<script>` tag in `<head>`, that eliminates the polling.
   *
   * @private
   */


  function _datalayerReady() {
    if (!_dataLayerReadyPromise) {
      _dataLayerReadyPromise = new Promise(function (resolve, reject) {
        /**
         * Tracks the number of attempts for the datalayer ready loop
         *
         * @type {number}
         * @private
         */
        var _attempt = 0;

        function _dataLayerReadyImpl() {
          if (_checkFlag()) {
            resolve();
          } else {
            _attempt++;

            if (_attempt < _timeoutRetries) {
              setTimeout(function () {
                _dataLayerReadyImpl();
              }, 100);
            } else {
              reject(new Error('Timeout polling for digital data object.'));
            }
          }
        }

        _dataLayerReadyImpl();
      });
    }

    return _dataLayerReadyPromise;
  }
  /**
   * DDO API class with methods of fetching search results for
   * ibm.com
   */


  var DDOAPI = /*#__PURE__*/function () {
    function DDOAPI() {
      classCallCheck(this, DDOAPI);
    }

    createClass(DDOAPI, null, [{
      key: "isReady",

      /**
       * Promise function that determines when the digital data object is ready
       *
       * @returns {Promise} Resolved data layer ready signal
       */
      value: function isReady() {
        return _datalayerReady();
      }
      /**
       * Gets the full digitalData (DDO) object.
       * Application should `window.digitalData` up-front, e.g. in a `<script>` tag in `<head>`.
       * For quick developerment purpose, what `ibm-common.js` automatically populates can be used.
       *
       * @returns {Promise<*>} Promise object
       */

    }, {
      key: "getAll",
      value: function () {
        var _getAll = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return this.isReady().then(function () {
                    return lib.digitalData;
                  }).catch(function () {
                    return null;
                  });

                case 2:
                  return _context.abrupt("return", _context.sent);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function getAll() {
          return _getAll.apply(this, arguments);
        }

        return getAll;
      }()
      /**
       * Sets the version of the library to the DDO.
       * Application should `window.digitalData` up-front, e.g. in a `<script>` tag in `<head>`.
       * For quick developerment purpose, what `ibm-common.js` automatically populates can be used.
       *
       * @returns {Promise<any>} Promise object
       */

    }, {
      key: "setVersion",
      value: function () {
        var _setVersion = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.isReady().then(function () {
                    lib.digitalData.page.pageInfo.version = settings.version;
                  });

                case 2:
                  return _context2.abrupt("return", _context2.sent);

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function setVersion() {
          return _setVersion.apply(this, arguments);
        }

        return setVersion;
      }()
      /**
       * Gets the locale for the current page based on the language set as metadata.
       * Application should `window.digitalData` up-front, e.g. in a `<script>` tag in `<head>`.
       * For quick developerment purpose, what `ibm-common.js` automatically populates can be used.
       *
       * @returns {Promise<*>} Promise object
       */

    }, {
      key: "getLanguage",
      value: function () {
        var _getLanguage = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return this.isReady().then(function () {
                    return lib.digitalData.page.pageInfo.language;
                  });

                case 2:
                  return _context3.abrupt("return", _context3.sent);

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getLanguage() {
          return _getLanguage.apply(this, arguments);
        }

        return getLanguage;
      }()
    }]);

    return DDOAPI;
  }();

  /**
   * Copyright IBM Corp. 2020
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */
  /**
   * Flag to determine if the global init has been fired
   *
   * @type {boolean}
   * @private
   */

  var _initialized = false;
  /**
   * Initializes various global functions
   */

  function globalInit() {
    if (_initialized) {
      return;
    } else {
      _initialized = true;
    } // Sets the version of the library in the DDO


    DDOAPI.setVersion().catch(function (error) {
      console.error('Error setting the version of the library in the DDO:', error);
    }); // analytics tracking

    AnalyticsAPI.initAll();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      return fn.apply(thisArg, args);
    };
  };

  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  var isBuffer = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
  };

  /*global toString:true*/
  // utils is a library of generic helper functions non-specific to axios


  var toString = Object.prototype.toString;
  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */

  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }
  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */


  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }
  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */


  function isFormData(val) {
    return typeof FormData !== 'undefined' && val instanceof FormData;
  }
  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */


  function isArrayBufferView(val) {
    var result;

    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }

    return result;
  }
  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */


  function isString(val) {
    return typeof val === 'string';
  }
  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */


  function isNumber(val) {
    return typeof val === 'number';
  }
  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */


  function isUndefined(val) {
    return typeof val === 'undefined';
  }
  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */


  function isObject(val) {
    return val !== null && _typeof_1(val) === 'object';
  }
  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */


  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }
  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */


  function isFile(val) {
    return toString.call(val) === '[object File]';
  }
  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */


  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }
  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */


  function isFunction(val) {
    return toString.call(val) === '[object Function]';
  }
  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */


  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */


  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }
  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */


  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }
  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */


  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
      return false;
    }

    return typeof window !== 'undefined' && typeof document !== 'undefined';
  }
  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */


  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    } // Force an array if not already something iterable


    if (_typeof_1(obj) !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */


  function merge()
  /* obj1, obj2, obj3, ... */
  {
    var result = {};

    function assignValue(val, key) {
      if (_typeof_1(result[key]) === 'object' && _typeof_1(val) === 'object') {
        result[key] = merge(result[key], val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }

    return result;
  }
  /**
   * Function equal to merge with the difference being that no reference
   * to original objects is kept.
   *
   * @see merge
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */


  function deepMerge()
  /* obj1, obj2, obj3, ... */
  {
    var result = {};

    function assignValue(val, key) {
      if (_typeof_1(result[key]) === 'object' && _typeof_1(val) === 'object') {
        result[key] = deepMerge(result[key], val);
      } else if (_typeof_1(val) === 'object') {
        result[key] = deepMerge({}, val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }

    return result;
  }
  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */


  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }

  var utils = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    deepMerge: deepMerge,
    extend: extend,
    trim: trim
  };

  function encode(val) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }
  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */


  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;

    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }

          parts.push(encode(key) + '=' + encode(v));
        });
      });
      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */


  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */


  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */


  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */


  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */

  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;

    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function () {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };

    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */


  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */


  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;

    if (!validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
    }
  };

  // c.f. https://nodejs.org/api/http.html#http_message_headers


  var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */

  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) {
      return parsed;
    }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }

        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });
    return parsed;
  };

  var isURLSameOrigin = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */

    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */

    return function isURLSameOrigin(requestURL) {
      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();

  var cookies = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  }() : // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() {
        return null;
      },
      remove: function remove() {}
    };
  }();

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest(); // HTTP basic authentication

      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS

      request.timeout = config.timeout; // Listen for ready state

      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // Prepare the response


        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };
        settle(resolve, reject, response); // Clean up request

        request = null;
      }; // Handle browser request cancellation (as opposed to a manual cancellation)


      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Handle low level network errors


      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request)); // Clean up request

        request = null;
      }; // Handle timeout


      request.ontimeout = function handleTimeout() {
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.


      if (utils.isStandardBrowserEnv()) {
        var cookies$1 = cookies; // Add xsrf header

        var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies$1.read(config.xsrfCookieName) : undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      } // Add headers to the request


      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      } // Add withCredentials to request if needed


      if (config.withCredentials) {
        request.withCredentials = true;
      } // Add responseType to request if needed


      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      } // Handle progress if needed


      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      } // Not all browsers support upload events


      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel); // Clean up request

          request = null;
        });
      }

      if (requestData === undefined) {
        requestData = null;
      } // Send the request


      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter; // Only Node.JS has a process variable that is of [[Class]] process

    if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    } else if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    }

    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');

      if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }

      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }

      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }

      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }

      return data;
    }],
    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) {
          /* Ignore */
        }
      }

      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };
  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults;

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */

  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */

  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
  };

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */


  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config); // Support baseURL config

    if (config.baseURL && !isAbsoluteURL(config.url)) {
      config.url = combineURLs(config.baseURL, config.url);
    } // Ensure headers exist


    config.headers = config.headers || {}; // Transform request data

    config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
    utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults_1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config); // Transform response data

      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config); // Transform response data

        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */


  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      }
    });
    utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
      if (utils.isObject(config2[prop])) {
        config[prop] = utils.deepMerge(config1[prop], config2[prop]);
      } else if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (utils.isObject(config1[prop])) {
        config[prop] = utils.deepMerge(config1[prop]);
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });
    utils.forEach(['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath'], function defaultToConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });
    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */


  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */


  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config);
    config.method = config.method ? config.method.toLowerCase() : 'get'; // Hook up interceptors middleware

    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  }; // Provide aliases for supported request methods


  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function (url, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url
      }));
    };
  });
  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function (url, data, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });
  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */

  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */


  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */


  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */

  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */


  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context); // Copy axios.prototype to instance

    utils.extend(instance, Axios_1.prototype, context); // Copy context to instance

    utils.extend(instance, context);
    return instance;
  } // Create the default instance to be exported


  var axios = createInstance(defaults_1); // Expose Axios class to allow class inheritance

  axios.Axios = Axios_1; // Factory for creating new instances

  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  }; // Expose Cancel & CancelToken


  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel; // Expose all/spread

  axios.all = function all(promises) {
    return Promise.all(promises);
  };

  axios.spread = spread;
  var axios_1 = axios; // Allow use of default import syntax in TypeScript

  var default_1 = axios;
  axios_1.default = default_1;

  var axios$1 = axios_1;

  function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator$1(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var _endpoint = process && process.env.GEO_API || 'https://api.www.s81c.com/webmaster/dbip/';
  /**
   * Utility to retrieve user's country code based on their IP address
   *
   * @example
   * import { geolocation } from '@carbon/ibmdotcom-utilities';
   *
   * const locationInfo = await geolocation();
   *
   * @returns {string} country cc (cc)
   *
   */


  function geolocation() {
    return _geolocation.apply(this, arguments);
  }

  function _geolocation() {
    _geolocation = _asyncToGenerator$1( /*#__PURE__*/regenerator.mark(function _callee() {
      var location, cc;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return axios$1.get(_endpoint, {
                headers: {
                  'Content-Type': 'application/json; charset=utf-8'
                }
              }).then(function (response) {
                return response.data;
              });

            case 2:
              location = _context.sent;
              cc = location && location.country;
              return _context.abrupt("return", cc);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _geolocation.apply(this, arguments);
  }

  var js_cookie = createCommonjsModule(function (module, exports) {

    (function (factory) {
      var registeredInModuleLoader;

      {
        module.exports = factory();
        registeredInModuleLoader = true;
      }

      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();

        api.noConflict = function () {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function () {
      function extend() {
        var i = 0;
        var result = {};

        for (; i < arguments.length; i++) {
          var attributes = arguments[i];

          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }

        return result;
      }

      function decode(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }

      function init(converter) {
        function api() {}

        function set(key, value, attributes) {
          if (typeof document === 'undefined') {
            return;
          }

          attributes = extend({
            path: '/'
          }, api.defaults, attributes);

          if (typeof attributes.expires === 'number') {
            attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
          } // We're using "expires" because "max-age" is not supported by IE


          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

          try {
            var result = JSON.stringify(value);

            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {}

          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = '';

          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }

            stringifiedAttributes += '; ' + attributeName;

            if (attributes[attributeName] === true) {
              continue;
            } // Considers RFC 6265 section 5.2:
            // ...
            // 3.  If the remaining unparsed-attributes contains a %x3B (";")
            //     character:
            // Consume the characters of the unparsed-attributes up to,
            // not including, the first %x3B (";") character.
            // ...


            stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
          }

          return document.cookie = key + '=' + value + stringifiedAttributes;
        }

        function get(key, json) {
          if (typeof document === 'undefined') {
            return;
          }

          var jar = {}; // To prevent the for loop in the first place assign an empty array
          // in case there are no cookies at all.

          var cookies = document.cookie ? document.cookie.split('; ') : [];
          var i = 0;

          for (; i < cookies.length; i++) {
            var parts = cookies[i].split('=');
            var cookie = parts.slice(1).join('=');

            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }

            try {
              var name = decode(parts[0]);
              cookie = (converter.read || converter)(cookie, name) || decode(cookie);

              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {}
              }

              jar[name] = cookie;

              if (key === name) {
                break;
              }
            } catch (e) {}
          }

          return key ? jar[key] : jar;
        }

        api.set = set;

        api.get = function (key) {
          return get(key, false
          /* read as raw */
          );
        };

        api.getJSON = function (key) {
          return get(key, true
          /* read as json */
          );
        };

        api.remove = function (key, attributes) {
          set(key, '', extend(attributes, {
            expires: -1
          }));
        };

        api.defaults = {};
        api.withConverter = init;
        return api;
      }

      return init(function () {});
    });
  });

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }
  /**
   * Name of cookie needed to grab cc and lc
   *
   * @type {string}
   * @private
   */

  var _cookieName = 'ipcInfo';
  /**
   * Utility to set and get the ipcInfo cookie needed to determine country and language code
   */

  var ipcinfoCookie = /*#__PURE__*/function () {
    function ipcinfoCookie() {
      _classCallCheck$1(this, ipcinfoCookie);
    }

    _createClass$1(ipcinfoCookie, null, [{
      key: "get",

      /**
       * retreive the ipcInfo cookie that contains the cc and lc
       * decodes and converts to object
       *
       * @example
       * import { ipcinfoCookie } from '@carbon/ibmdotcom-utilities';
       *
       * const info = ipcinfoCookie.get();
       *
       *
       * @returns {object} object containing cc and lc
       */
      value: function get() {
        var ipcinfo = js_cookie.get(_cookieName);

        if (ipcinfo) {
          var cc;
          var lc;
          var info = decodeURIComponent(ipcinfo).split(';');
          info.map(function (code) {
            var itemParts = code.split('=');
            if (itemParts[0] === 'cc') cc = itemParts[1];
            if (itemParts[0] === 'lc') lc = itemParts[1];
          });
          return {
            cc: cc,
            lc: lc
          };
        }
      }
      /**
       * set the ipcInfo cookie with expiration of a year
       * takes care of converting to string and encoding
       *
       * @param {object} params params object
       * @param {string} params.cc country code
       * @param {string} params.lc language code
       *
       * @example
       * import { ipcinfoCookie } from '@carbon/ibmdotcom-utilities';
       *
       * const locale = {cc: 'us', lc: 'en'}
       * ipcinfoCookie.set(locale);
       *
       */

    }, {
      key: "set",
      value: function set(_ref) {
        var cc = _ref.cc,
            lc = _ref.lc;
        var info = "cc=".concat(cc, ";lc=").concat(lc);
        js_cookie.set(_cookieName, encodeURIComponent(info), {
          expires: 365
        }, {
          secure: true
        });
      }
    }]);

    return ipcinfoCookie;
  }();

  var _root$location;
  /**
   * @constant {string | string} Host for the Locale API call
   * @private
   */

  var _host = process && (process.env.REACT_APP_TRANSLATION_HOST || process.env.TRANSLATION_HOST) || 'https://www.ibm.com';
  /**
   * @constant {string | string} CORS proxy for lower environment calls
   * @private
   */


  var _proxy = ((_root$location = lib.location) === null || _root$location === void 0 ? void 0 : _root$location.host) === 'www.ibm.com' ? '' : // Optional chaining operator in `process.env.ENVVAR` does not work in some build systems, notably Parcel
  process && (process.env.REACT_APP_CORS_PROXY || process.env.CORS_PROXY) || '';
  /**
   * Sets the default location if nothing is returned
   *
   * @type {object}
   * @private
   */


  var _localeDefault = {
    lc: 'en',
    cc: 'us'
  };
  /**
   * Default display name for lang combination
   *
   * @type {string}
   * @private
   */

  var _localeNameDefault = 'United States — English';
  /**
   * Locale API endpoint
   *
   * @type {string}
   * @private
   */

  var _endpoint$1 = "".concat(_proxy).concat(_host, "/common/js/dynamicnav/www/countrylist/jsononly");
  /**
   * Tracking of the country list fetch
   *
   * @type {{}}
   * @private
   */


  var _listFetch = {};
  /**
   * Number of times to retry the fetch before failing
   *
   * @type {number}
   * @private
   */

  var _timeoutRetries$1 = 50;
  /**
   * Tracks the number of attempts for the fetch
   *
   * @type {number}
   * @private
   */

  var _attempt = 0;
  /**
   * Configuration for axios
   *
   * @type {{headers: {'Content-Type': string}}}
   * @private
   */

  var _axiosConfig = {
    headers: {
      'Content-Type': 'application/json; charset=utf-8'
    }
  };
  /**
   * Session Storage key for country list
   *
   * @type {string}
   * @private
   */

  var _sessionListKey = 'dds-countrylist';
  /**
   * Use the <html> lang attr to determine a return locale object
   *
   * @type {object}
   * @private
   */

  var _getLocaleByLangAttr = function _getLocaleByLangAttr() {
    if (lib.document.documentElement.lang) {
      var lang = lib.document.documentElement.lang.toLowerCase();

      if (lang.indexOf('-') === -1) {
        return _localeDefault;
      } else {
        var codes = lang.split('-');
        return {
          cc: codes[1],
          lc: codes[0]
        };
      }
    } else {
      return _localeDefault;
    }
  };
  /**
   * The cache for in-flight or resolved requests for the country list, keyed by the initiating locale.
   *
   * @type {object<string, LocaleList>}
   */


  var _requestsList = {};
  /**
   * Return a locale object based on the DDO API, or "false"
   * so the consumer can decide what to do next
   *
   * @type {(object | boolean)}
   * @private
   */

  function _getLocaleFromDDO() {
    return _getLocaleFromDDO2.apply(this, arguments);
  }
  /**
   * Locale API class with method of fetching user's locale for
   * ibm.com
   */


  function _getLocaleFromDDO2() {
    _getLocaleFromDDO2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
      var ddoLocal, pageInfoIBM;
      return regenerator.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return DDOAPI.getAll();

            case 2:
              ddoLocal = _context5.sent;

              if (!(ddoLocal && ddoLocal.page && ddoLocal.page.pageInfo)) {
                _context5.next = 10;
                break;
              }

              pageInfoIBM = ddoLocal.page.pageInfo.ibm; // Set proper LC for us to use.

              if (ddoLocal.page.pageInfo.language) {
                pageInfoIBM.lc = ddoLocal.page.pageInfo.language.substring(0, 2).toLowerCase();
              }

              if (pageInfoIBM) {
                // Set proper CC for us to use.
                if (pageInfoIBM.country) {
                  pageInfoIBM.cc = pageInfoIBM.country.toLowerCase().trim(); // If there are multiple countries use just the first one for the CC value

                  if (pageInfoIBM.cc.indexOf(',') > -1) pageInfoIBM.cc = pageInfoIBM.cc.substring(0, pageInfoIBM.cc.indexOf(',')).trim(); // Gb will be uk elsewhere

                  if (pageInfoIBM.cc === 'gb') pageInfoIBM.cc = 'uk'; // Map worldwide (ZZ) pages to US

                  if (pageInfoIBM.cc === 'zz') pageInfoIBM.cc = 'us';
                }
              }

              if (!(!pageInfoIBM.lc || !pageInfoIBM.cc)) {
                _context5.next = 9;
                break;
              }

              return _context5.abrupt("return", false);

            case 9:
              return _context5.abrupt("return", {
                cc: pageInfoIBM.cc,
                lc: pageInfoIBM.lc
              });

            case 10:
              return _context5.abrupt("return", false);

            case 11:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _getLocaleFromDDO2.apply(this, arguments);
  }

  var LocaleAPI = /*#__PURE__*/function () {
    function LocaleAPI() {
      classCallCheck(this, LocaleAPI);
    }

    createClass(LocaleAPI, null, [{
      key: "clearCache",

      /**
       * Clears the cache.
       */
      value: function clearCache() {
        Object.keys(_requestsList).forEach(function (key) {
          return delete _requestsList[key];
        });

        for (var i = 0; i < sessionStorage.length; ++i) {
          var key = sessionStorage.key(i);

          if (key.indexOf(_sessionListKey) === 0) {
            sessionStorage.removeItem(key);
          }
        }
      }
      /**
       * Gets the user's locale
       *
       * Grab the locale from the `lang` attribute from html, else
       * check if ipcinfo cookie exists (ipcinfoCookie util)
       * if not, retrieve the user's locale through geolocation util + gets user's
       * browser language preference then set the cookie
       *
       * @returns {object} object with lc and cc
       *
       * @example
       * import { LocaleAPI } from '@carbon/ibmdotcom-services';
       *
       * async function getLocale() {
       *   const locale = await LocaleAPI.getLocale();
       *   return locale;
       * }
       */

    }, {
      key: "getLocale",
      value: function () {
        var _getLocale = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var cookie, lang, cc, _lang, lc, list, verifiedCodes;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  cookie = ipcinfoCookie.get();
                  _context.next = 3;
                  return this.getLang();

                case 3:
                  lang = _context.sent;

                  if (!lang) {
                    _context.next = 10;
                    break;
                  }

                  _context.next = 7;
                  return this.getList(lang);

                case 7:
                  return _context.abrupt("return", lang);

                case 10:
                  if (!(cookie && cookie.cc && cookie.lc)) {
                    _context.next = 16;
                    break;
                  }

                  _context.next = 13;
                  return this.getList(cookie);

                case 13:
                  return _context.abrupt("return", cookie);

                case 16:
                  _context.next = 18;
                  return geolocation();

                case 18:
                  cc = _context.sent;

                  /**
                   * get language preference from browser
                   * can return in either 'en-US' format or 'en' so will need to extract language only
                   */
                  _lang = lib.navigator.language;
                  lc = _lang.split('-')[0];

                  if (!(cc && lc)) {
                    _context.next = 28;
                    break;
                  }

                  _context.next = 24;
                  return this.getList({
                    cc: cc,
                    lc: lc
                  });

                case 24:
                  list = _context.sent;
                  verifiedCodes = this.verifyLocale(cc, lc, list); // set the ipcInfo cookie

                  ipcinfoCookie.set(verifiedCodes);
                  return _context.abrupt("return", verifiedCodes);

                case 28:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function getLocale() {
          return _getLocale.apply(this, arguments);
        }

        return getLocale;
      }()
      /**
       * Checks for DDO object to return the correct cc and lc
       * Otherwise gets those values from the <html> lang attribute
       *
       * @returns {object} locale object
       *
       * @example
       * import { LocaleAPI } from '@carbon/ibmdotcom-services';
       *
       * function async getLocale() {
       *    const locale = await LocaleAPI.getLang();
       * }
       */

    }, {
      key: "getLang",
      value: function () {
        var _getLang = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var getLocaleFromDDO;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _getLocaleFromDDO();

                case 2:
                  getLocaleFromDDO = _context2.sent;

                  if (!getLocaleFromDDO) {
                    _context2.next = 7;
                    break;
                  }

                  return _context2.abrupt("return", getLocaleFromDDO);

                case 7:
                  return _context2.abrupt("return", _getLocaleByLangAttr());

                case 8:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function getLang() {
          return _getLang.apply(this, arguments);
        }

        return getLang;
      }()
      /**
       * This fetches the language display name based on language/locale combo
       *
       * @param {object} langCode lang code with cc and lc
       *
       * @returns {Promise<string>} Display name of locale/language
       */

    }, {
      key: "getLangDisplay",
      value: function () {
        var _getLangDisplay = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(langCode) {
          var lang, list, countries, location;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!langCode) {
                    _context3.next = 4;
                    break;
                  }

                  _context3.t0 = langCode;
                  _context3.next = 7;
                  break;

                case 4:
                  _context3.next = 6;
                  return this.getLang();

                case 6:
                  _context3.t0 = _context3.sent;

                case 7:
                  lang = _context3.t0;
                  _context3.next = 10;
                  return this.getList(lang);

                case 10:
                  list = _context3.sent;
                  // combines the countryList arrays
                  countries = [];
                  list.regionList.forEach(function (region) {
                    countries = countries.concat(region.countryList);
                  }); // get match for countries with multiple languages

                  location = countries.filter(function (country) {
                    var htmlLang = country.locale.findIndex(function (loc) {
                      return loc[0] === "".concat(lang.lc, "-").concat(lang.cc);
                    });

                    if (htmlLang !== -1) {
                      var _country$locale;

                      var localeMatch = country.locale.filter(function (l) {
                        return l.includes("".concat(lang.lc, "-").concat(lang.cc));
                      });

                      (_country$locale = country.locale).splice.apply(_country$locale, [0, country.locale.length].concat(toConsumableArray(localeMatch)));

                      return country;
                    }
                  });

                  if (!location.length) {
                    _context3.next = 18;
                    break;
                  }

                  return _context3.abrupt("return", "".concat(location[0].name, " \u2014 ").concat(location[0].locale[0][1]));

                case 18:
                  return _context3.abrupt("return", _localeNameDefault);

                case 19:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getLangDisplay(_x) {
          return _getLangDisplay.apply(this, arguments);
        }

        return getLangDisplay;
      }()
      /**
       * Get the country list of all supported countries and their languages
       * if not set in session storage
       *
       * @param {object} params params object
       * @param {string} params.cc country code
       * @param {string} params.lc language code
       *
       * @returns {Promise<any>} promise object
       *
       * @example
       * import { LocaleAPI } from '@carbon/ibmdotcom-services';
       *
       * function async getLocale() {
       *    const list = await LocaleAPI.getList({ cc: 'us', lc: 'en' });
       *    return list;
       * }
       */

    }, {
      key: "getList",
      value: function () {
        var _getList = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(_ref) {
          var _this = this;

          var cc, lc, key, cachedRequest;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  cc = _ref.cc, lc = _ref.lc;
                  key = "".concat(lc, "-").concat(cc);
                  cachedRequest = _requestsList[key];

                  if (!cachedRequest) {
                    _context4.next = 5;
                    break;
                  }

                  return _context4.abrupt("return", cachedRequest);

                case 5:
                  return _context4.abrupt("return", _requestsList[key] = new Promise(function (resolve, reject) {
                    _this.fetchList(cc, lc, resolve, reject);
                  }));

                case 6:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        function getList(_x2) {
          return _getList.apply(this, arguments);
        }

        return getList;
      }()
      /**
       * Fetches the list data based on cc/lc combination
       *
       * @param {string} cc country code
       * @param {string} lc language code
       * @param {Function} resolve resolves the Promise
       * @param {Function} reject rejects the promise
       */

    }, {
      key: "fetchList",
      value: function fetchList(cc, lc, resolve, reject) {
        var _this2 = this;

        var sessionList = JSON.parse(sessionStorage.getItem("".concat(_sessionListKey, "-").concat(cc, "-").concat(lc)));

        if (sessionList) {
          resolve(sessionList);
        } else if (_listFetch["".concat(cc, "-").concat(lc)]) {
          _attempt++;

          if (_attempt < _timeoutRetries$1) {
            setTimeout(function () {
              _this2.fetchList(cc, lc, resolve, reject);
            }, 100);
          } else {
            reject();
          }
        } else {
          var url = "".concat(_endpoint$1, "/").concat(cc).concat(lc, "-utf8.json");
          _attempt = 0;
          _listFetch["".concat(cc, "-").concat(lc)] = true;
          axios$1.get(url, _axiosConfig).then(function (response) {
            sessionStorage.setItem("".concat(_sessionListKey, "-").concat(cc, "-").concat(lc), JSON.stringify(response.data));
            _listFetch["".concat(cc, "-").concat(lc)] = false;
            resolve(response.data);
          }).catch(function () {
            if (cc === _localeDefault.cc && lc === _localeDefault.lc) {
              _listFetch["".concat(cc, "-").concat(lc)] = false;
              reject();
            } else {
              _this2.fetchList(_localeDefault.cc, _localeDefault.lc, resolve, reject);
            }
          });
        }
      }
      /**
       * Verify that the cc and lc combo is in the list of
       * supported cc-lc combos
       *
       * @param {string} cc country code
       * @param {string} lc language code
       * @param {object} list country list
       *
       * @returns {object} object with lc and cc
       * @example
       * import { LocaleAPI } from '@carbon/ibmdotcom-services';
       *
       * async function getLocale() {
       *   const locale = await LocaleAPI.verifyLocale(cc, lc, data);
       *   return locale;
       * }
       */

    }, {
      key: "verifyLocale",
      value: function verifyLocale(cc, lc, list) {
        var priorityLC;
        var locale;
        var language = list && list.regionList.forEach(function (region) {
          return region.countryList.forEach(function (country) {
            var code = country.locale[0][0].split('-');
            var countryCode = code[1];
            var languageCode = code[0];

            if (countryCode === cc && languageCode === lc) {
              locale = {
                cc: cc,
                lc: lc
              };
            } // save the priority language associated with the user's country code
            else if (countryCode === cc && !priorityLC) {
                priorityLC = languageCode;
              }
          });
        });

        if (!language && priorityLC) {
          locale = {
            cc: cc,
            lc: priorityLC
          };
        }

        return locale;
      }
    }]);

    return LocaleAPI;
  }();

  /**
   * @constant {string | string} Host for the API calls
   * @private
   */

  var _host$1 = process && process.env.MARKETING_SEARCH_HOST || 'https://www.ibm.com';
  /**
   * @constant {string | string} API version
   * @private
   */


  var _version = process && process.env.MARKETING_SEARCH_VERSION || 'v3';
  /**
   * MarketingSearch endpoint
   *
   * @type {string}
   * @private
   */


  var _endpoint$2 = "".concat(_host$1, "/marketplace/api/search/").concat(_version, "/combined_suggestions");
  /**
   * MarketingSearch API class with methods of fetching search results for
   * ibm.com
   */


  var MarketingSearchAPI = /*#__PURE__*/function () {
    function MarketingSearchAPI() {
      classCallCheck(this, MarketingSearchAPI);
    }

    createClass(MarketingSearchAPI, null, [{
      key: "getResults",

      /**
       * Gets search results for marketing
       *
       * @param {string} query Query string to pass to the service
       * @returns {Promise<any>} Response data from ibm search
       * @example
       * import { MarketingSearchAPI } from '@carbon/ibmdotcom-services';
       *
       * async function getResults(query) {
       *   const response = await MarketingSearchAPI.getResults(query);
       *   return response;
       * }
       */
      value: function () {
        var _getResults = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(query) {
          var lc, cc, url;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  lc = 'en'; // TODO: create utility for fetching lc

                  cc = 'us'; // TODO: create utility for fetching cc

                  url = "".concat(_endpoint$2, "?locale=").concat(lc, "-").concat(cc, "&q=").concat(encodeURIComponent(query));
                  _context.next = 5;
                  return axios$1.get(url, {
                    headers: {
                      'Content-Type': 'application/json; charset=utf-8'
                    }
                  }).then(function (response) {
                    return response.data;
                  });

                case 5:
                  return _context.abrupt("return", _context.sent);

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getResults(_x) {
          return _getResults.apply(this, arguments);
        }

        return getResults;
      }()
    }]);

    return MarketingSearchAPI;
  }();

  /**
   * Helpers.
   */
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var ms = function ms(val, options) {
    options = options || {};

    var type = _typeof_1(val);

    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */


  function parse(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;

      case 'days':
      case 'day':
      case 'd':
        return n * d;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }

    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }

    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }

    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }

    return ms + 'ms';
  }
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function fmtLong(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }
  /**
   * Pluralization helper.
   */


  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }

    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }

    return Math.ceil(ms / n) + ' ' + name + 's';
  }

  var debug = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms;
    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];
    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};
    /**
     * Previous log timestamp.
     */

    var prevTime;
    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0,
          i;

      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */


    function createDebug(namespace) {
      function debug() {
        // disabled?
        if (!debug.enabled) return;
        var self = debug; // set `diff` timestamp

        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr; // turn the `arguments` into a proper Array

        var args = new Array(arguments.length);

        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        } // apply any `formatters` transformations


        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];

          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }

          return match;
        }); // apply env-specific formatting (colors, etc.)

        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace); // env-specific initialization logic for debug instances

      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      return debug;
    }
    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */


    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    /**
     * Disable debug output.
     *
     * @api public
     */


    function disable() {
      exports.enable('');
    }
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */


    function enabled(name) {
      var i, len;

      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }
    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */


    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  });
  var debug_1 = debug.coerce;
  var debug_2 = debug.disable;
  var debug_3 = debug.enable;
  var debug_4 = debug.enabled;
  var debug_5 = debug.humanize;
  var debug_6 = debug.names;
  var debug_7 = debug.skips;
  var debug_8 = debug.formatters;

  var browser = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = debug;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
    /**
     * Colors.
     */

    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      } // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */


    exports.formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */


    function formatArgs(args) {
      var useColors = this.useColors;
      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
      if (!useColors) return;
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if ('%%' === match) return;
        index++;

        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */


    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === (typeof console === "undefined" ? "undefined" : _typeof_1(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */


    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */


    function load() {
      var r;

      try {
        r = exports.storage.debug;
      } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }
    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */


    exports.enable(load());
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  });
  var browser_1 = browser.log;
  var browser_2 = browser.formatArgs;
  var browser_3 = browser.save;
  var browser_4 = browser.load;
  var browser_5 = browser.useColors;
  var browser_6 = browser.storage;
  var browser_7 = browser.colors;

  /**
   * Module dependencies
   */

  var debug$1 = browser('jsonp');
  /**
   * Module exports.
   */

  var jsonp_1 = jsonp;
  /**
   * Callback index.
   */

  var count = 0;
  /**
   * Noop function.
   */

  function noop() {}
  /**
   * JSONP handler
   *
   * Options:
   *  - param {String} qs parameter (`callback`)
   *  - prefix {String} qs parameter (`__jp`)
   *  - name {String} qs parameter (`prefix` + incr)
   *  - timeout {Number} how long after a timeout error is emitted (`60000`)
   *
   * @param {String} url
   * @param {Object|Function} optional options / callback
   * @param {Function} optional callback
   */


  function jsonp(url, opts, fn) {
    if ('function' == typeof opts) {
      fn = opts;
      opts = {};
    }

    if (!opts) opts = {};
    var prefix = opts.prefix || '__jp'; // use the callback name that was passed if one was provided.
    // otherwise generate a unique name by incrementing our counter.

    var id = opts.name || prefix + count++;
    var param = opts.param || 'callback';
    var timeout = null != opts.timeout ? opts.timeout : 60000;
    var enc = encodeURIComponent;
    var target = document.getElementsByTagName('script')[0] || document.head;
    var script;
    var timer;

    if (timeout) {
      timer = setTimeout(function () {
        cleanup();
        if (fn) fn(new Error('Timeout'));
      }, timeout);
    }

    function cleanup() {
      if (script.parentNode) script.parentNode.removeChild(script);
      window[id] = noop;
      if (timer) clearTimeout(timer);
    }

    function cancel() {
      if (window[id]) {
        cleanup();
      }
    }

    window[id] = function (data) {
      debug$1('jsonp got', data);
      cleanup();
      if (fn) fn(null, data);
    }; // add qs component


    url += (~url.indexOf('?') ? '&' : '?') + param + '=' + enc(id);
    url = url.replace('?&', '?');
    debug$1('jsonp req "%s"', url); // create script

    script = document.createElement('script');
    script.src = url;
    target.parentNode.insertBefore(script, target);
    return cancel;
  }

  /**
   * @constant {string | string} Host for the profile status API call
   * @private
   */

  var _host$2 = process && process.env.PROFILE_HOST || 'https://idaas.iam.ibm.com';
  /**
   * @constant {string | string} API version
   * @private
   */


  var _version$1 = process && process.env.PROFILE_VERSION || 'v1';
  /**
   * Profile status endpoint
   *
   * @type {string}
   * @private
   */


  var _endpoint$3 = "".concat(_host$2, "/").concat(_version$1, "/mgmt/idaas/user/status/");
  /**
   * Profile API class with methods for checking user authentication for ibm.com
   */


  var ProfileAPI = /*#__PURE__*/function () {
    function ProfileAPI() {
      classCallCheck(this, ProfileAPI);
    }

    createClass(ProfileAPI, null, [{
      key: "getUserStatus",

      /**
       * Returns user status (authenticated or unauthenticated)
       *
       * @returns {Promise<any>} User status
       * @example
       * import { ProfileAPI } from '@carbon/ibmdotcom-services';
       *
       * async function getUserStatus() {
       *   const response = await ProfileAPI.getUserStatus();
       *   return response;
       * }
       */
      value: function getUserStatus() {
        var url = _endpoint$3;
        return new Promise(function (resolve, reject) {
          return jsonp_1(url, null, function (err, data) {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      /**
       * Monitors user status (authenticated or unauthenticated)
       *
       * @example
       * import { ProfileAPI } from '@carbon/ibmdotcom-services';
       *
       * function monitorUserStatus() {
       *   ProfileAPI.monitorUserStatus((err, status) => {
       *     console.log('The new login status:', status.user);
       *   });
       * }
       */

    }, {
      key: "monitorUserStatus",
      value: function monitorUserStatus(callback) {
        return jsonp_1(_endpoint$3, null, callback);
      }
    }]);

    return ProfileAPI;
  }();

  /**
   * @constant {string | string} Host for the API calls
   * @private
   */

  var _host$3 = process && process.env.SEARCH_TYPEAHEAD_HOST || 'https://www-api.ibm.com';
  /**
   * @constant {string | string} API version
   * @private
   */


  var _version$2 = process && process.env.SEARCH_TYPEAHEAD_VERSION || 'v1';
  /**
   * SearchTypeahead endpoint
   *
   * @type {string}
   * @private
   */


  var _endpoint$4 = "".concat(_host$3, "/search/typeahead/").concat(_version$2);
  /**
   * SearchTypeahead API class with methods of fetching search results for
   * ibm.com
   */


  var SearchTypeaheadAPI = /*#__PURE__*/function () {
    function SearchTypeaheadAPI() {
      classCallCheck(this, SearchTypeaheadAPI);
    }

    createClass(SearchTypeaheadAPI, null, [{
      key: "getResults",

      /**
       * Gets search results
       *
       * @param {string} query Query string to pass to the service
       * @returns {Promise<any>} Response data from ibm search
       * @example
       * import { SearchTypeaheadAPI } from '@carbon/ibmdotcom-services';
       *
       * async function getResults(query) {
       *   const response = await SearchTypeaheadAPI.getResults(query);
       *   return response;
       * }
       */
      value: function () {
        var _getResults = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(query) {
          var lang, urlQuery, url;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return LocaleAPI.getLang();

                case 2:
                  lang = _context.sent;
                  urlQuery = ["lang=".concat(lang.lc), "cc=".concat(lang.cc), "query=".concat(encodeURIComponent(query))].join('&');
                  url = "".concat(_endpoint$4, "?").concat(urlQuery);
                  _context.next = 7;
                  return axios$1.get(url, {
                    headers: {
                      'Content-Type': 'application/json; charset=utf-8'
                    }
                  }).then(function (response) {
                    return response.data.response;
                  });

                case 7:
                  return _context.abrupt("return", _context.sent);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getResults(_x) {
          return _getResults.apply(this, arguments);
        }

        return getResults;
      }()
    }]);

    return SearchTypeaheadAPI;
  }();

  var _root$location$1;
  /**
   * @constant {string | string} Host for the Translation API call
   * @private
   */

  var _host$4 = process && (process.env.REACT_APP_TRANSLATION_HOST || process.env.TRANSLATION_HOST) || 'https://www.ibm.com';
  /**
   * @constant {string | string} CORS proxy for lower environment calls
   * @private
   */


  var _proxy$1 = ((_root$location$1 = lib.location) === null || _root$location$1 === void 0 ? void 0 : _root$location$1.host) === 'www.ibm.com' ? '' : // Optional chaining operator in `process.env.ENVVAR` does not work in some build systems, notably Parcel
  process && (process.env.REACT_APP_CORS_PROXY || process.env.CORS_PROXY) || '';
  /**
   * Translation API endpoint
   *
   * @type {string}
   * @private
   */


  var _endpoint$5 = "".concat(_host$4, "/common/v18/js/data/jsononly");
  /**
   * Session Storage key for translation data
   *
   * @type {string}
   * @private
   */


  var _sessionTranslationKey = 'dds-translation';
  /**
   * Tracking of the translation fetch
   *
   * @type {{}}
   * @private
   */

  var _translationFetch = {};
  /**
   * Number of times to retry the fetch before failing
   *
   * @type {number}
   * @private
   */

  var _timeoutRetries$2 = 50;
  /**
   * Tracks the number of attempts for the fetch
   *
   * @type {number}
   * @private
   */

  var _attempt$1 = 0;
  /**
   * The cache for in-flight or resolved requests for the i18n data, keyed by the initiating locale.
   *
   * @type {object<string, Translation>}
   */

  var _requestsTranslation = {};
  /**
   * Translation API class with methods for fetching i18n data for ibm.com
   */

  var TranslationAPI = /*#__PURE__*/function () {
    function TranslationAPI() {
      classCallCheck(this, TranslationAPI);
    }

    createClass(TranslationAPI, null, [{
      key: "clearCache",

      /**
       * Clears the cache.
       */
      value: function clearCache() {
        Object.keys(_requestsTranslation).forEach(function (key) {
          return delete _requestsTranslation[key];
        });

        for (var i = 0; i < sessionStorage.length; ++i) {
          var key = sessionStorage.key(i);

          if (key.indexOf(_sessionTranslationKey) === 0) {
            sessionStorage.removeItem(key);
          }
        }
      }
      /**
       * Returns translation i18n data
       *
       * @param {object} codes object containing lc and cc
       *
       * @returns {Promise<any>} Translation data
       * @example
       * import { TranslationAPI } from '@carbon/ibmdotcom-services';
       *
       * async function getTranslation() {
       *   const response = await TranslationAPI.getTranslation({
       *     lc: 'en',
       *     cc: 'us',
       *   });
       *   return response;
       * }
       */

    }, {
      key: "getTranslation",
      value: function () {
        var _getTranslation = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(codes) {
          var _this = this;

          var lang, country, locale, key, cachedRequest;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  lang = 'en';
                  country = 'us';

                  if (!(codes && codes.lc && codes.cc)) {
                    _context.next = 7;
                    break;
                  }

                  lang = codes.lc;
                  country = codes.cc;
                  _context.next = 12;
                  break;

                case 7:
                  _context.next = 9;
                  return LocaleAPI.getLocale();

                case 9:
                  locale = _context.sent;
                  lang = locale.lc;
                  country = locale.cc;

                case 12:
                  key = "".concat(lang, "-").concat(country);
                  cachedRequest = _requestsTranslation[key];

                  if (!cachedRequest) {
                    _context.next = 16;
                    break;
                  }

                  return _context.abrupt("return", cachedRequest);

                case 16:
                  return _context.abrupt("return", _requestsTranslation[key] = new Promise(function (resolve, reject) {
                    _this.fetchTranslation(lang, country, resolve, reject);
                  }));

                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getTranslation(_x) {
          return _getTranslation.apply(this, arguments);
        }

        return getTranslation;
      }()
      /**
       * Fetches the translation data from sessionStorage or data fetch
       *
       * @param {string} lang Language code
       * @param {string} country Country code
       * @param {Function} resolve resolves the Promise
       * @param {Function} reject rejects the promise
       */

    }, {
      key: "fetchTranslation",
      value: function fetchTranslation(lang, country, resolve, reject) {
        var _this2 = this;

        var sessionTranslation = JSON.parse(sessionStorage.getItem("".concat(_sessionTranslationKey, "-").concat(country, "-").concat(lang)));

        if (sessionTranslation) {
          resolve(sessionTranslation);
        } else if (_translationFetch["".concat(country, "-").concat(lang)]) {
          _attempt$1++;

          if (_attempt$1 < _timeoutRetries$2) {
            setTimeout(function () {
              _this2.fetchTranslation(lang, country, resolve, reject);
            }, 100);
          } else {
            reject();
          }
        } else {
          var proxy = '';

          if (lib.location) {
            var currenthost = "".concat(lib.location.protocol, "//").concat(lib.location.host);
            proxy = currenthost !== _host$4 ? _proxy$1 : '';
          }

          var url = "".concat(proxy).concat(_endpoint$5, "/").concat(country).concat(lang, ".json");
          _attempt$1 = 0;
          _translationFetch["".concat(country, "-").concat(lang)] = true;
          axios$1.get(url, {
            headers: {
              'Content-Type': 'text/plain',
              origin: _host$4
            }
          }).then(function (response) {
            var data = _this2.transformData(response.data);

            sessionStorage.setItem("".concat(_sessionTranslationKey, "-").concat(country, "-").concat(lang), JSON.stringify(data));
            _translationFetch["".concat(country, "-").concat(lang)] = false;
            resolve(data);
          }).catch(function (error) {
            _translationFetch["".concat(country, "-").concat(lang)] = false;
            reject(error);
          });
        }
      }
      /**
       * Transforms translation data
       *
       * @param   {object} data translation data to be transformed
       * @returns {object} Translation data
       */

    }, {
      key: "transformData",
      value: function transformData(data) {
        data.footerMenu.push(data.socialFollow);
        return data;
      }
    }]);

    return TranslationAPI;
  }();

  /**
   * Sets the Kaltura Partner ID, set by environment variable "KALTURA_PARTNER_ID"
   *
   * @type {number}
   * @private
   */

  var _partnerId = process.env.KALTURA_PARTNER_ID || 1773841;
  /**
   * Sets the Kaltura UIConf ID, set by environment variable "KALTURA_UICONF_ID"
   *
   * @type {number}
   * @private
   */


  var _uiConfId = process.env.KALTURA_UICONF_ID || 27941801;
  /**
   * @type {string} _embedUrl The API URL to call
   * @private
   */


  var _embedUrl = "https://cdnapisec.kaltura.com/p/".concat(_partnerId, "/sp/").concat(_partnerId, "00/embedIframeJs/uiconf_id/").concat(_uiConfId, "/partner_id/").concat(_partnerId);
  /**
   * @type {string} _thumbnailUrl
   * @private
   */


  var _thumbnailUrl = "https://cdnsecakmi.kaltura.com/p/".concat(_partnerId, "/thumbnail/entry_id/");
  /**
   * Number of times to retry the script ready loop before failing
   *
   * @type {number}
   * @private
   */


  var _timeoutRetries$3 = 50;
  /**
   * Tracks the number of attempts for the script ready loop
   *
   * @type {number}
   * @private
   */

  var _attempt$2 = 0;
  /**
   * Tracks the script status
   *
   * @type {boolean} _scriptLoading to track the script loading or not
   * @private
   */

  var _scriptLoading = false;
  /**
   * Timeout loop to check script state is the _scriptLoaded state or _scriptLoading state
   *
   * @param {Function} resolve Resolve function
   * @param {Function} reject Reject function
   * @private
   */

  function _scriptReady(resolve, reject) {
    /**
     *
     * @param {object} root.kWidget if exists then resolve
     */
    if (lib.kWidget) {
      _scriptLoading = false;
      resolve();
    } else if (_scriptLoading) {
      _attempt$2++;

      if (_attempt$2 < _timeoutRetries$3) {
        setTimeout(function () {
          _scriptReady(resolve, reject);
        }, 100);
      } else {
        reject();
      }
    } else {
      _loadScript();

      _scriptReady(resolve, reject);
    }
  }
  /**
   * Returns boolean if the _scriptLoading and _scriptLoaded flag is false
   *
   * @private
   */


  function _loadScript() {
    _scriptLoading = true;
    var script = document.createElement('script');
    script.src = _embedUrl;
    script.async = true;
    document.body.appendChild(script);
  }
  /**
   *
   * Object to cache video data
   *
   * @private
   */


  var videoData = {};
  /**
   * VideoPlayerAPI class with methods of checking script state and
   * embed video meta data and api data
   *
   * In order to set the Partner ID/UIConf ID, set the following environment
   * variables:
   *
   * - KALTURA_PARTNER_ID
   * - KALTURA_UICONF_ID
   */

  var VideoPlayerAPI = /*#__PURE__*/function () {
    function VideoPlayerAPI() {
      classCallCheck(this, VideoPlayerAPI);
    }

    createClass(VideoPlayerAPI, null, [{
      key: "checkScript",

      /**
       *
       * Gets the full _scriptReady state
       *
       * @returns {Promise<*>} Promise kaltura video player file
       */
      value: function checkScript() {
        return new Promise(function (resolve, reject) {
          _scriptReady(resolve, reject);
        });
      }
      /**
       * Creates thumbnail image url with customizable params
       *
       * @param {object} params param object
       * @param {string} params.videoId video id
       * @param {string} params.height specify height in pixels
       * @param {string} params.width specify width in pixels
       *
       * @returns {string} url of thumbnail image
       *
       * @example
       * import { VideoPlayerAPI } from '@carbon/ibmdotcom-services';
       *
       * function thumbnail() {
       *   const thumbnailData = {
       *      videoId: '0_uka1msg4',
       *      height: '240',
       *      width: '320'
       *   }
       *   const thumbnailUrl = VideoPlayerAPI.getThumbnailUrl(thumbnailData);
       * }
       */

    }, {
      key: "getThumbnailUrl",
      value: function getThumbnailUrl(_ref) {
        var videoId = _ref.videoId,
            height = _ref.height,
            width = _ref.width;
        var url = _thumbnailUrl + videoId;
        if (height) url = url + "/height/".concat(height);
        if (width) url = url + "/width/".concat(width);
        return url;
      }
      /**
       * Gets the embed meta data
       *
       * @param {string} videoId  The videoId we're embedding the placeholder for.
       * @param {string} targetId The targetId the ID where we're putting the placeholder.
       * @param {boolean} autoPlay Determine whether to autoplay on load of video.
       * @returns {object}  object
       *
       * @example
       * import { VideoPlayerAPI } from '@carbon/ibmdotcom-services';
       *
       * function embedMyVideo() {
       *   const elem = document.getElementById('foo');
       *   const videoid = '12345';
       *   VideoPlayerAPI.embedVideo(videoid, elem);
       * }
       */

    }, {
      key: "embedVideo",
      value: function () {
        var _embedVideo = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(videoId, targetId, autoPlay) {
          var fireEvent;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  fireEvent = this.fireEvent;
                  _context.next = 3;
                  return this.checkScript().then(function () {
                    var promiseKWidget = new Promise(function (resolve) {
                      lib.kWidget.embed({
                        targetId: targetId,
                        wid: '_' + _partnerId,
                        uiconf_id: _uiConfId,
                        entry_id: videoId,
                        flashvars: {
                          autoPlay: autoPlay,
                          titleLabel: {
                            plugin: true,
                            align: 'left',
                            text: '{mediaProxy.entry.name}'
                          }
                        },
                        // Ready callback is issued for this player:
                        readyCallback: function readyCallback(playerId) {
                          var kdp = document.getElementById(playerId);
                          kdp.addJsListener('playerPaused', function () {
                            fireEvent({
                              playerState: 1,
                              kdp: kdp,
                              videoId: videoId
                            });
                          });
                          kdp.addJsListener('playerPlayed', function () {
                            fireEvent({
                              playerState: 2,
                              kdp: kdp,
                              videoId: videoId
                            });
                          });
                          kdp.addJsListener('playerPlayEnd', function () {
                            fireEvent({
                              playerState: 3,
                              kdp: kdp,
                              videoId: videoId
                            });
                          });
                          resolve(kdp);
                        }
                      });
                    });
                    return {
                      kWidget: function kWidget() {
                        return promiseKWidget;
                      }
                    };
                  });

                case 3:
                  return _context.abrupt("return", _context.sent);

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function embedVideo(_x, _x2, _x3) {
          return _embedVideo.apply(this, arguments);
        }

        return embedVideo;
      }()
      /**
       * Fires a metrics event when the video was played.
       * Pass events to common metrics event.
       *
       * @param {object} param params
       * @param {number} param.playerState state detecting different user actions
       * @param {object} param.kdp video object
       * @param {string} param.videoId id of the video
       *
       */

    }, {
      key: "fireEvent",
      value: function fireEvent(_ref2) {
        var playerState = _ref2.playerState,
            kdp = _ref2.kdp,
            videoId = _ref2.videoId;
        // If video was played and timestamp is 0, it should be "launched" state.
        var currentTime = Math.round(kdp.evaluate('{video.player.currentTime}'));

        if (playerState === 2 && currentTime === 0) {
          playerState = 0;
        }

        var eventData = {
          playerType: 'kaltura',
          title: kdp.evaluate('{mediaProxy.entry.name}'),
          currentTime: currentTime,
          duration: kdp.evaluate('{mediaProxy.entry.duration}'),
          playerState: playerState,
          videoId: videoId
        };
        AnalyticsAPI.videoPlayerStats(eventData);
      }
      /**
       * Gets the api data
       *
       * @param {string} videoId  The videoId we're embedding the placeholder for.
       * @returns {object}  object
       *
       * @example
       * import { VideoPlayerAPI } from '@carbon/ibmdotcom-services';
       *
       * async function getMyVideoInfo(id) {
       *   const data = await VideoPlayerAPI.api(id);
       *   console.log(data);
       * }
       */

    }, {
      key: "api",
      value: function () {
        var _api = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(videoId) {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.checkScript().then(function () {
                    if (videoData && videoData[videoId]) {
                      return videoData[videoId];
                    } else {
                      return new Promise(function (resolve) {
                        return new lib.kWidget.api({
                          wid: '_' + _partnerId
                        }).doRequest({
                          service: 'media',
                          action: 'get',
                          entryId: videoId
                        }, function (jsonObj) {
                          videoData[jsonObj.id] = jsonObj;
                          resolve(jsonObj);
                        });
                      });
                    }
                  });

                case 2:
                  return _context2.abrupt("return", _context2.sent);

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function api(_x4) {
          return _api.apply(this, arguments);
        }

        return api;
      }()
      /**
       * Convert video duration from milliseconds to HH:MM:SS
       *
       * @param {string} duration video duration in milliseconds
       * @returns {string} converted duration
       */

    }, {
      key: "getVideoDuration",
      value: function getVideoDuration(duration) {
        var seconds = Math.floor(duration / 1000 % 60);
        var minutes = Math.floor(duration / (1000 * 60) % 60);
        var hours = Math.floor(duration / (1000 * 60 * 60) % 24);
        hours = hours > 0 ? hours + ':' : '';
        seconds = seconds < 10 ? '0' + seconds : seconds;
        return duration && '(' + hours + minutes + ':' + seconds + ')';
      }
    }]);

    return VideoPlayerAPI;
  }();

  exports.AnalyticsAPI = AnalyticsAPI;
  exports.DDOAPI = DDOAPI;
  exports.LocaleAPI = LocaleAPI;
  exports.MarketingSearchAPI = MarketingSearchAPI;
  exports.ProfileAPI = ProfileAPI;
  exports.SearchTypeaheadAPI = SearchTypeaheadAPI;
  exports.TranslationAPI = TranslationAPI;
  exports.VideoPlayerAPI = VideoPlayerAPI;
  exports.globalInit = globalInit;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
