import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";

var _root$location;

/**
 * Copyright IBM Corp. 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import axios from 'axios';
import DDOAPI from '../DDO/DDO';
import geolocation from '@carbon/ibmdotcom-utilities/es/utilities/geolocation/geolocation';
import ipcinfoCookie from '@carbon/ibmdotcom-utilities/es/utilities/ipcinfoCookie/ipcinfoCookie';
import root from 'window-or-global';
/**
 * @constant {string | string} Host for the Locale API call
 * @private
 */

var _host = process && (process.env.REACT_APP_TRANSLATION_HOST || process.env.TRANSLATION_HOST) || 'https://www.ibm.com';
/**
 * @constant {string | string} CORS proxy for lower environment calls
 * @private
 */


var _proxy = ((_root$location = root.location) === null || _root$location === void 0 ? void 0 : _root$location.host) === 'www.ibm.com' ? '' : // Optional chaining operator in `process.env.ENVVAR` does not work in some build systems, notably Parcel
process && (process.env.REACT_APP_CORS_PROXY || process.env.CORS_PROXY) || '';
/**
 * Sets the default location if nothing is returned
 *
 * @type {object}
 * @private
 */


var _localeDefault = {
  lc: 'en',
  cc: 'us'
};
/**
 * Default display name for lang combination
 *
 * @type {string}
 * @private
 */

var _localeNameDefault = 'United States â€” English';
/**
 * Locale API endpoint
 *
 * @type {string}
 * @private
 */

var _endpoint = "".concat(_proxy).concat(_host, "/common/js/dynamicnav/www/countrylist/jsononly");
/**
 * Tracking of the country list fetch
 *
 * @type {{}}
 * @private
 */


var _listFetch = {};
/**
 * Number of times to retry the fetch before failing
 *
 * @type {number}
 * @private
 */

var _timeoutRetries = 50;
/**
 * Tracks the number of attempts for the fetch
 *
 * @type {number}
 * @private
 */

var _attempt = 0;
/**
 * Configuration for axios
 *
 * @type {{headers: {'Content-Type': string}}}
 * @private
 */

var _axiosConfig = {
  headers: {
    'Content-Type': 'application/json; charset=utf-8'
  }
};
/**
 * Session Storage key for country list
 *
 * @type {string}
 * @private
 */

var _sessionListKey = 'dds-countrylist';
/**
 * Use the <html> lang attr to determine a return locale object
 *
 * @type {object}
 * @private
 */

var _getLocaleByLangAttr = function _getLocaleByLangAttr() {
  if (root.document.documentElement.lang) {
    var lang = root.document.documentElement.lang.toLowerCase();

    if (lang.indexOf('-') === -1) {
      return _localeDefault;
    } else {
      var codes = lang.split('-');
      return {
        cc: codes[1],
        lc: codes[0]
      };
    }
  } else {
    return _localeDefault;
  }
};
/**
 * The cache for in-flight or resolved requests for the country list, keyed by the initiating locale.
 *
 * @type {object<string, LocaleList>}
 */


var _requestsList = {};
/**
 * Return a locale object based on the DDO API, or "false"
 * so the consumer can decide what to do next
 *
 * @type {(object | boolean)}
 * @private
 */

function _getLocaleFromDDO() {
  return _getLocaleFromDDO2.apply(this, arguments);
}
/**
 * Locale API class with method of fetching user's locale for
 * ibm.com
 */


function _getLocaleFromDDO2() {
  _getLocaleFromDDO2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
    var ddoLocal, pageInfoIBM;
    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return DDOAPI.getAll();

          case 2:
            ddoLocal = _context5.sent;

            if (!(ddoLocal && ddoLocal.page && ddoLocal.page.pageInfo)) {
              _context5.next = 10;
              break;
            }

            pageInfoIBM = ddoLocal.page.pageInfo.ibm; // Set proper LC for us to use.

            if (ddoLocal.page.pageInfo.language) {
              pageInfoIBM.lc = ddoLocal.page.pageInfo.language.substring(0, 2).toLowerCase();
            }

            if (pageInfoIBM) {
              // Set proper CC for us to use.
              if (pageInfoIBM.country) {
                pageInfoIBM.cc = pageInfoIBM.country.toLowerCase().trim(); // If there are multiple countries use just the first one for the CC value

                if (pageInfoIBM.cc.indexOf(',') > -1) pageInfoIBM.cc = pageInfoIBM.cc.substring(0, pageInfoIBM.cc.indexOf(',')).trim(); // Gb will be uk elsewhere

                if (pageInfoIBM.cc === 'gb') pageInfoIBM.cc = 'uk'; // Map worldwide (ZZ) pages to US

                if (pageInfoIBM.cc === 'zz') pageInfoIBM.cc = 'us';
              }
            }

            if (!(!pageInfoIBM.lc || !pageInfoIBM.cc)) {
              _context5.next = 9;
              break;
            }

            return _context5.abrupt("return", false);

          case 9:
            return _context5.abrupt("return", {
              cc: pageInfoIBM.cc,
              lc: pageInfoIBM.lc
            });

          case 10:
            return _context5.abrupt("return", false);

          case 11:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _getLocaleFromDDO2.apply(this, arguments);
}

var LocaleAPI = /*#__PURE__*/function () {
  function LocaleAPI() {
    _classCallCheck(this, LocaleAPI);
  }

  _createClass(LocaleAPI, null, [{
    key: "clearCache",

    /**
     * Clears the cache.
     */
    value: function clearCache() {
      Object.keys(_requestsList).forEach(function (key) {
        return delete _requestsList[key];
      });

      for (var i = 0; i < sessionStorage.length; ++i) {
        var key = sessionStorage.key(i);

        if (key.indexOf(_sessionListKey) === 0) {
          sessionStorage.removeItem(key);
        }
      }
    }
    /**
     * Gets the user's locale
     *
     * Grab the locale from the `lang` attribute from html, else
     * check if ipcinfo cookie exists (ipcinfoCookie util)
     * if not, retrieve the user's locale through geolocation util + gets user's
     * browser language preference then set the cookie
     *
     * @returns {object} object with lc and cc
     *
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * async function getLocale() {
     *   const locale = await LocaleAPI.getLocale();
     *   return locale;
     * }
     */

  }, {
    key: "getLocale",
    value: function () {
      var _getLocale = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var cookie, lang, cc, _lang, lc, list, verifiedCodes;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cookie = ipcinfoCookie.get();
                _context.next = 3;
                return this.getLang();

              case 3:
                lang = _context.sent;

                if (!lang) {
                  _context.next = 10;
                  break;
                }

                _context.next = 7;
                return this.getList(lang);

              case 7:
                return _context.abrupt("return", lang);

              case 10:
                if (!(cookie && cookie.cc && cookie.lc)) {
                  _context.next = 16;
                  break;
                }

                _context.next = 13;
                return this.getList(cookie);

              case 13:
                return _context.abrupt("return", cookie);

              case 16:
                _context.next = 18;
                return geolocation();

              case 18:
                cc = _context.sent;

                /**
                 * get language preference from browser
                 * can return in either 'en-US' format or 'en' so will need to extract language only
                 */
                _lang = root.navigator.language;
                lc = _lang.split('-')[0];

                if (!(cc && lc)) {
                  _context.next = 28;
                  break;
                }

                _context.next = 24;
                return this.getList({
                  cc: cc,
                  lc: lc
                });

              case 24:
                list = _context.sent;
                verifiedCodes = this.verifyLocale(cc, lc, list); // set the ipcInfo cookie

                ipcinfoCookie.set(verifiedCodes);
                return _context.abrupt("return", verifiedCodes);

              case 28:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getLocale() {
        return _getLocale.apply(this, arguments);
      }

      return getLocale;
    }()
    /**
     * Checks for DDO object to return the correct cc and lc
     * Otherwise gets those values from the <html> lang attribute
     *
     * @returns {object} locale object
     *
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * function async getLocale() {
     *    const locale = await LocaleAPI.getLang();
     * }
     */

  }, {
    key: "getLang",
    value: function () {
      var _getLang = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var getLocaleFromDDO;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _getLocaleFromDDO();

              case 2:
                getLocaleFromDDO = _context2.sent;

                if (!getLocaleFromDDO) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", getLocaleFromDDO);

              case 7:
                return _context2.abrupt("return", _getLocaleByLangAttr());

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function getLang() {
        return _getLang.apply(this, arguments);
      }

      return getLang;
    }()
    /**
     * This fetches the language display name based on language/locale combo
     *
     * @param {object} langCode lang code with cc and lc
     *
     * @returns {Promise<string>} Display name of locale/language
     */

  }, {
    key: "getLangDisplay",
    value: function () {
      var _getLangDisplay = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(langCode) {
        var lang, list, countries, location;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!langCode) {
                  _context3.next = 4;
                  break;
                }

                _context3.t0 = langCode;
                _context3.next = 7;
                break;

              case 4:
                _context3.next = 6;
                return this.getLang();

              case 6:
                _context3.t0 = _context3.sent;

              case 7:
                lang = _context3.t0;
                _context3.next = 10;
                return this.getList(lang);

              case 10:
                list = _context3.sent;
                // combines the countryList arrays
                countries = [];
                list.regionList.forEach(function (region) {
                  countries = countries.concat(region.countryList);
                }); // get match for countries with multiple languages

                location = countries.filter(function (country) {
                  var htmlLang = country.locale.findIndex(function (loc) {
                    return loc[0] === "".concat(lang.lc, "-").concat(lang.cc);
                  });

                  if (htmlLang !== -1) {
                    var _country$locale;

                    var localeMatch = country.locale.filter(function (l) {
                      return l.includes("".concat(lang.lc, "-").concat(lang.cc));
                    });

                    (_country$locale = country.locale).splice.apply(_country$locale, [0, country.locale.length].concat(_toConsumableArray(localeMatch)));

                    return country;
                  }
                });

                if (!location.length) {
                  _context3.next = 18;
                  break;
                }

                return _context3.abrupt("return", "".concat(location[0].name, " \u2014 ").concat(location[0].locale[0][1]));

              case 18:
                return _context3.abrupt("return", _localeNameDefault);

              case 19:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getLangDisplay(_x) {
        return _getLangDisplay.apply(this, arguments);
      }

      return getLangDisplay;
    }()
    /**
     * Get the country list of all supported countries and their languages
     * if not set in session storage
     *
     * @param {object} params params object
     * @param {string} params.cc country code
     * @param {string} params.lc language code
     *
     * @returns {Promise<any>} promise object
     *
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * function async getLocale() {
     *    const list = await LocaleAPI.getList({ cc: 'us', lc: 'en' });
     *    return list;
     * }
     */

  }, {
    key: "getList",
    value: function () {
      var _getList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref) {
        var _this = this;

        var cc, lc, key, cachedRequest;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                cc = _ref.cc, lc = _ref.lc;
                key = "".concat(lc, "-").concat(cc);
                cachedRequest = _requestsList[key];

                if (!cachedRequest) {
                  _context4.next = 5;
                  break;
                }

                return _context4.abrupt("return", cachedRequest);

              case 5:
                return _context4.abrupt("return", _requestsList[key] = new Promise(function (resolve, reject) {
                  _this.fetchList(cc, lc, resolve, reject);
                }));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function getList(_x2) {
        return _getList.apply(this, arguments);
      }

      return getList;
    }()
    /**
     * Fetches the list data based on cc/lc combination
     *
     * @param {string} cc country code
     * @param {string} lc language code
     * @param {Function} resolve resolves the Promise
     * @param {Function} reject rejects the promise
     */

  }, {
    key: "fetchList",
    value: function fetchList(cc, lc, resolve, reject) {
      var _this2 = this;

      var sessionList = JSON.parse(sessionStorage.getItem("".concat(_sessionListKey, "-").concat(cc, "-").concat(lc)));

      if (sessionList) {
        resolve(sessionList);
      } else if (_listFetch["".concat(cc, "-").concat(lc)]) {
        _attempt++;

        if (_attempt < _timeoutRetries) {
          setTimeout(function () {
            _this2.fetchList(cc, lc, resolve, reject);
          }, 100);
        } else {
          reject();
        }
      } else {
        var url = "".concat(_endpoint, "/").concat(cc).concat(lc, "-utf8.json");
        _attempt = 0;
        _listFetch["".concat(cc, "-").concat(lc)] = true;
        axios.get(url, _axiosConfig).then(function (response) {
          sessionStorage.setItem("".concat(_sessionListKey, "-").concat(cc, "-").concat(lc), JSON.stringify(response.data));
          _listFetch["".concat(cc, "-").concat(lc)] = false;
          resolve(response.data);
        }).catch(function () {
          if (cc === _localeDefault.cc && lc === _localeDefault.lc) {
            _listFetch["".concat(cc, "-").concat(lc)] = false;
            reject();
          } else {
            _this2.fetchList(_localeDefault.cc, _localeDefault.lc, resolve, reject);
          }
        });
      }
    }
    /**
     * Verify that the cc and lc combo is in the list of
     * supported cc-lc combos
     *
     * @param {string} cc country code
     * @param {string} lc language code
     * @param {object} list country list
     *
     * @returns {object} object with lc and cc
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * async function getLocale() {
     *   const locale = await LocaleAPI.verifyLocale(cc, lc, data);
     *   return locale;
     * }
     */

  }, {
    key: "verifyLocale",
    value: function verifyLocale(cc, lc, list) {
      var priorityLC;
      var locale;
      var language = list && list.regionList.forEach(function (region) {
        return region.countryList.forEach(function (country) {
          var code = country.locale[0][0].split('-');
          var countryCode = code[1];
          var languageCode = code[0];

          if (countryCode === cc && languageCode === lc) {
            locale = {
              cc: cc,
              lc: lc
            };
          } // save the priority language associated with the user's country code
          else if (countryCode === cc && !priorityLC) {
              priorityLC = languageCode;
            }
        });
      });

      if (!language && priorityLC) {
        locale = {
          cc: cc,
          lc: priorityLC
        };
      }

      return locale;
    }
  }]);

  return LocaleAPI;
}();

export default LocaleAPI;