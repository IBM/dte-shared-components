import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";

/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import React, { useCallback, useEffect, useReducer, useRef } from 'react';
import Autosuggest from 'react-autosuggest';
import Close20 from '@carbon/icons-react/es/close/20';
import cx from 'classnames';
import ddsSettings from '@carbon/ibmdotcom-utilities/es/utilities/settings/settings';
import escapeRegExp from '@carbon/ibmdotcom-utilities/es/utilities/escaperegexp/escaperegexp';
import HeaderGlobalAction from '../../internal/vendor/carbon-components-react/components/UIShell/HeaderGlobalAction';
import LocaleAPI from '@carbon/ibmdotcom-services/es/services/Locale/Locale';
import MastheadSearchInput from './MastheadSearchInput';
import MastheadSearchSuggestion from './MastheadSearchSuggestion';
import PropTypes from 'prop-types';
import root from 'window-or-global';
import Search20 from '@carbon/icons-react/es/search/20';
import SearchTypeaheadAPI from '@carbon/ibmdotcom-services/es/services/SearchTypeahead/SearchTypeahead';
import settings from 'carbon-components/es/globals/js/settings';
var stablePrefix = ddsSettings.stablePrefix;
var prefix = settings.prefix;
/**
 * Sets up the redirect URL when a user selects a search suggestion
 *
 * @type {string}
 * @private
 */

var _redirectUrl = process.env.SEARCH_REDIRECT_ENDPOINT || "https://www.ibm.com/search?lnk=mhsrch";
/**
 * Converts the string to lower case and trims extra white space
 *
 * @param {string} valueString The text field
 * @returns {string} lower cased and trimmed text
 */


var _trimAndLower = function _trimAndLower(valueString) {
  return valueString.toLowerCase().trim();
};
/**
 * When a suggestion item is clicked, we populate the input with its name field
 *
 * @param {object} suggestion The individual object from the data
 * @returns {*} The name val
 */


var _getSuggestionValue = function _getSuggestionValue(suggestion) {
  return suggestion[0];
};
/**
 * Reducer for the useReducer hook
 *
 * @param {object} state The state
 * @param {object} action contains the type and payload
 * @returns {*} the new state value
 * @private
 */


function _reducer(state, action) {
  switch (action.type) {
    case 'setVal':
      return Object.assign({}, state, {
        val: action.payload.val
      });

    case 'emptySuggestions':
      return Object.assign({}, state, {
        suggestions: []
      });

    case 'setPrevSuggestions':
      return Object.assign({}, state, {
        prevSuggestions: action.payload.prevSuggestions
      });

    case 'setSuggestionsToPrevious':
      return Object.assign({}, state, {
        suggestions: state.prevSuggestions
      });

    case 'showSuggestionsContainer':
      return Object.assign({}, state, {
        suggestionContainerVisible: true
      });

    case 'hideSuggestionsContainer':
      return Object.assign({}, state, {
        suggestionContainerVisible: false
      });

    case 'setSearchOpen':
      return Object.assign({}, state, {
        isSearchOpen: true
      });

    case 'setSearchClosed':
      return Object.assign({}, state, {
        isSearchOpen: false
      });

    case 'setLc':
      return Object.assign({}, state, {
        lc: action.payload.lc
      });

    case 'setCc':
      return Object.assign({}, state, {
        cc: action.payload.cc
      });

    default:
      return state;
  }
}
/**
 * MastheadSearch component which includes autosuggestion results from the
 * SearchTypeaheadAPI.
 *
 * The search field utilizes "react-autosuggest". Documentation available here:
 * http://react-autosuggest.js.org/
 * https://github.com/moroshko/react-autosuggest
 */


var MastheadSearch = function MastheadSearch(_ref) {
  var _cx;

  var placeHolderText = _ref.placeHolderText,
      renderValue = _ref.renderValue,
      searchOpenOnload = _ref.searchOpenOnload,
      navType = _ref.navType;

  var _useSearchVisible = useSearchVisible(false),
      ref = _useSearchVisible.ref;
  /**
   * Initial state of the autocomplete component
   *
   * @type {{val: string, prevSuggestions: Array, suggestions: Array, suggestionContainerVisible: boolean}}
   * @private
   */


  var _initialState = {
    val: '',
    suggestions: [],
    prevSuggestions: [],
    suggestionContainerVisible: false,
    isSearchOpen: searchOpenOnload,
    lc: 'en',
    cc: 'us'
  };

  var _useReducer = useReducer(_reducer, _initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  useEffect(function () {
    var abortController = typeof AbortController !== 'undefined' ? new AbortController() : {
      signal: {},
      abort: function abort() {
        this.signal.aborted = true;
      }
    };
    abortController.abort();

    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var response;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return LocaleAPI.getLang();

            case 2:
              response = _context.sent;

              if (!abortController.signal.aborted && response) {
                dispatch({
                  type: 'setLc',
                  payload: {
                    lc: response.lc
                  }
                });
                dispatch({
                  type: 'setCc',
                  payload: {
                    cc: response.cc
                  }
                });
              }

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();

    return function () {
      abortController.abort();
    };
  }, []);
  /**
   * Event handlers to toggle visiblity of search
   *
   * @returns {*} search ref
   */

  function useSearchVisible() {
    var ref = useRef(null);
    /**
     * Close search entirely if autosuggestions collapsed
     *
     * @param {*} event Escape keypress
     */

    var handleHideSearch = function handleHideSearch(event) {
      if (event.key === 'Escape') {
        if (!state.suggestionContainerVisible) {
          dispatch({
            type: 'setSearchClosed'
          });
        }
      }
    };
    /**
     * Close search when click detected outside of component.
     * This is necessary otherwise search stays open even when
     * elements other than the close button are clicked.
     *
     * @param {*} event Click event outside search component
     */


    var handleClickOutside = function handleClickOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        dispatch({
          type: 'setSearchClosed'
        });
      }
    };

    useEffect(function () {
      root.document.addEventListener('keydown', handleHideSearch, true);
      root.document.addEventListener('click', handleClickOutside, true);
      return function () {
        root.document.removeEventListener('keydown', handleHideSearch, true);
        root.document.removeEventListener('click', handleClickOutside, true);
      };
    });
    return {
      ref: ref
    };
  }

  var className = cx((_cx = {}, _defineProperty(_cx, "".concat(prefix, "--masthead__search"), true), _defineProperty(_cx, "".concat(prefix, "--masthead__search--active"), state.isSearchOpen), _cx));
  /**
   * When the input field changes, we set the new val to our state
   *
   * @param {event} event The callback event
   * @param {string} newValue The new val of the input
   */

  function onChange(event, _ref3) {
    var newValue = _ref3.newValue;
    dispatch({
      type: 'setVal',
      payload: {
        val: newValue
      }
    });
  }
  /**
   * Autosuggest will pass through all these props to the input.
   *
   * @type {{placeholder: string, value: string, onChange: Function, className: string}}
   */


  var inputProps = {
    placeholder: placeHolderText,
    value: state.val,
    onChange: onChange,
    className: "".concat(prefix, "--header__search--input")
  };
  /**
   * Executes the logic for the search icon depending on search input state.
   * This will execute the search if the search is open, or will open the
   * search field if closed.
   *
   */

  function searchIconClick() {
    if (state.isSearchOpen) {
      root.parent.location.href = getRedirect(state.val);
    } else {
      dispatch({
        type: 'setSearchOpen'
      });
    }
  }
  /**
   * Clear search and clear input when called
   */


  var resetSearch = useCallback(function () {
    dispatch({
      type: 'setSearchClosed'
    });
    dispatch({
      type: 'setVal',
      payload: {
        val: ''
      }
    });
  }, [dispatch]);
  /**
   * closeBtnAction resets and sets focus after search is closed
   */

  function closeBtnAction() {
    resetSearch();
    var searchIconRef = root.document.querySelectorAll("[data-autoid=\"".concat(stablePrefix, "--masthead-").concat(navType, "__l0-search\"]"));
    searchIconRef && searchIconRef[0].focus();
  }
  /**
   * Renders the input bar with the search icon
   *
   * @param {object} componentInputProps contains the input props
   * @returns {*} The rendered component
   */


  function renderInputComponent(componentInputProps) {
    return React.createElement(MastheadSearchInput, {
      componentInputProps: componentInputProps,
      dispatch: dispatch,
      isActive: state.isSearchOpen,
      searchIconClick: searchIconClick
    });
  }
  /**
   * Returns the action/redirect value
   *
   * @param {string} value string value from the input or suggestions list
   * @returns {string} final redirect string
   */


  function getRedirect(value) {
    return "".concat(_redirectUrl, "&q=").concat(encodeURIComponent(value), "&lang=").concat(state.lc, "&cc=").concat(state.cc);
  }
  /**
   * Renders the Suggestion Value with the function for the adding the suggestion
   *
   * @param {object} suggestion The suggestion to render
   * @param {object} properties The property object of the incoming suggestion
   * @param {string} properties.query The query being searched for
   * @param {boolean} properties.isHighlighted Whether the suggestion is currently highlighted by the user
   * @returns {*} The suggestion value
   */


  function renderSuggestion(suggestion, _ref4) {
    var query = _ref4.query,
        isHighlighted = _ref4.isHighlighted;
    return React.createElement(MastheadSearchSuggestion, {
      suggestion: suggestion,
      query: query,
      isHighlighted: isHighlighted,
      getSuggestionValue: _getSuggestionValue
    });
  }
  /**
   * This function is called everytime we need new suggestions. If input has
   * changed, we fetch for new suggestions else we return the previous
   * suggestions
   *
   * Available reason values:
   * https://github.com/moroshko/react-autosuggest#onsuggestionsfetchrequested-required
   *
   * @param {object} request Object response from when onSuggestionsFetchRequested is called
   * @param {string} request.value the current value of the input
   * @param {string} request.reason string describing why onSuggestionsFetchRequested was called
   */


  function onSuggestionsFetchRequest(_x) {
    return _onSuggestionsFetchRequest.apply(this, arguments);
  }
  /**
   * Called every time we clear suggestions
   */


  function _onSuggestionsFetchRequest() {
    _onSuggestionsFetchRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request) {
      var searchValue, response;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              searchValue = _trimAndLower(escapeRegExp(request.value));

              if (!(request.reason === 'input-changed')) {
                _context2.next = 8;
                break;
              }

              _context2.next = 4;
              return SearchTypeaheadAPI.getResults(searchValue);

            case 4:
              response = _context2.sent;

              if (response !== undefined) {
                dispatch({
                  type: 'setPrevSuggestions',
                  payload: {
                    prevSuggestions: response
                  }
                });
                dispatch({
                  type: 'setSuggestionsToPrevious'
                });
                dispatch({
                  type: 'showSuggestionsContainer'
                });
              }

              _context2.next = 9;
              break;

            case 8:
              if (request.reason === 'escape-pressed') {
                onSuggestionsClearedRequested();
              } else {
                dispatch({
                  type: 'setSuggestionsToPrevious'
                });
                dispatch({
                  type: 'showSuggestionsContainer'
                });
              }

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _onSuggestionsFetchRequest.apply(this, arguments);
  }

  function onSuggestionsClearedRequested() {
    dispatch({
      type: 'emptySuggestions'
    });
    dispatch({
      type: 'hideSuggestionsContainer'
    });
  }
  /**
   * Sends the user to the search results page when a suggestion is selected
   *
   * @param {object} event The event object
   * @param {object} params Param object coming from react-autosuggest
   * @param {string} params.suggestionValue Suggestion value
   */


  function onSuggestionSelected(event, _ref5) {
    var suggestionValue = _ref5.suggestionValue;
    root.parent.location.href = getRedirect(suggestionValue);
  }
  /**
   * Only render suggestions if we have more than the renderValue
   *
   * @param {string} value Name of the suggestion
   * @returns {boolean} Whether or not to display the value
   */


  function shouldRenderSuggestions(value) {
    return value.trim().length >= renderValue;
  }

  return React.createElement("div", {
    "data-autoid": "".concat(stablePrefix, "--masthead__search"),
    className: className,
    ref: ref
  }, state.isSearchOpen && React.createElement("form", {
    id: "".concat(prefix, "--masthead__search--form"),
    action: _redirectUrl,
    method: "get"
  }, React.createElement("input", {
    type: "hidden",
    name: "lang",
    value: state.lc
  }), React.createElement("input", {
    type: "hidden",
    name: "cc",
    value: state.cc
  }), React.createElement("input", {
    type: "hidden",
    name: "lnk",
    value: "mhsrch"
  }), React.createElement(Autosuggest, {
    suggestions: state.suggestions // The state value of suggestion
    ,
    onSuggestionsFetchRequested: onSuggestionsFetchRequest // Method to fetch data (should be async call)
    ,
    onSuggestionsClearRequested: onSuggestionsClearedRequested // When input bar loses focus
    ,
    getSuggestionValue: _getSuggestionValue // Name of suggestion
    ,
    renderSuggestion: renderSuggestion // How to display a suggestion
    ,
    onSuggestionSelected: onSuggestionSelected // When a suggestion is selected
    ,
    highlightFirstSuggestion: true // First suggestion is highlighted by default
    ,
    inputProps: inputProps,
    renderInputComponent: renderInputComponent,
    shouldRenderSuggestions: shouldRenderSuggestions
  })), React.createElement("div", {
    className: "".concat(prefix, "--header__search--actions")
  }, React.createElement(HeaderGlobalAction, {
    onClick: searchIconClick,
    "aria-label": state.isSearchOpen ? 'Search all of IBM' : 'Open IBM search field',
    className: "".concat(prefix, "--header__search--search"),
    "data-autoid": "".concat(stablePrefix, "--masthead-").concat(navType, "__l0-search"),
    tabIndex: "0"
  }, React.createElement(Search20, null)), React.createElement(HeaderGlobalAction, {
    onClick: closeBtnAction,
    "aria-label": "Close",
    className: "".concat(prefix, "--header__search--close"),
    "data-autoid": "".concat(stablePrefix, "--masthead-").concat(navType, "__l0-search--close")
  }, React.createElement(Close20, null))));
};

MastheadSearch.propTypes = {
  /**
   * Placeholder text for the search field.
   */
  placeHolderText: PropTypes.string,

  /**
   * Number of characters to begin showing suggestions.
   */
  renderValue: PropTypes.number,

  /**
   * `true` to make the search field open in the initial state.
   */
  searchOpenOnload: PropTypes.bool,

  /**
   * navigation type for autoids
   */
  navType: PropTypes.oneOf(['default, alt, eco'])
};
MastheadSearch.defaultProps = {
  placeHolderText: 'Search all of IBM',
  renderValue: 3,
  searchOpenOnload: false
}; // Export the react component

export default MastheadSearch;